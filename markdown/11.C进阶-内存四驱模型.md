# <center>C进阶：11.内存四驱模型<center>

# 1. 数组作为参数传递时获取不到长度的问题！！

原因：数组作为参数传递，会退化成为一个指针，传递的是首地址 （高效）

# 2. 数据类型剖析

数据类型的本质：`一块连续大小的内存空间 `  
数据类型的别名：int32_t     
void指针数据类型：`void*` 代表任意的数据类型的指针  


# 3. 变量的本质

- 变量的本质：固定内存块大小（一块连续大小的内存空间）的别名，通过变量可以去操作一块内存上的数据
- 变量的三要素：内存大小，名称，作用域

# 4. 内存四驱模型

## 4.1 程序运行的流程：

1. 操作系统会把物理硬盘上的代码 load 到内存
2. 加载到内存后会把 c 代码分成 4 个区
3. 然后系统会找到 main 函数的入口去执行

## 4.2  四驱模型

1. 栈区：由编译器自动分配的，存放一些局部变量值和函数，这个里面内存是会自动进行回收的
2. 堆区：一般都是由我们自己去开辟的，这个里面的内存需要手动进行释
3. 全局区：静态的一些常量，字符串 等等
4. 程序代码区：存放的是函数体的二进制代码

# 5. 栈的开口方向

- debug模式下：向下
- release模式下：向上

```c
void main(){
    int a = 10;
    int b = 10;
    // 0508 , 0496  a 的地址要大于 b 的地址 （debug）
    // 016  , 020   a 的地址要小于 b 的地址 （release）
    // buffer 数据类型跟栈的开口方向无关 （内部存储都是向上）

    char buff[10];
    // buff+1 -> buff
    printf("%p , %p , %p , %p",&a,&b,buff,buff+1);

    int a1 = 100;
    int* ff=  &a1; // 虽说是 a1 的地址，但是我也可以把 ff 看做一个数组

    // char** 二位数组 char** 二级指针

    ff += 1;

    getchar();
}
```

# 6. 指针强化

<font color=red>**一个指针的大小始终是32位系统占4个字节，64位系统占8字节**</font>

指针为什么要有类型：

1. 为了地址增量的方便：例如double型的地址增量为8，而int型指针的地址增量为4
2. 为了类型安全：帮助编译器发现你是否用了错误的类型

`指针是以内存地址作为变量地址`










