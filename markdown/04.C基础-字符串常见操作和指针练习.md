# <center>04.字符串常见操作和指针练习<center>
@[TOC](C基础)

# 知识点：

## 1.字符串定义

**字符串以 '\0' 结尾，动态开辟内存的时候也需要多考虑一位**
    
```c
    // 第一种 字符串数组 可以修改
    char str[] = {'D','a','r','r','e','n','\0'};
    // 第二种 不能修改
    const char *str1 = "Darren";
    
```
   

## 2.字符串长度获取

1. `strlen(name)`

2. 通过sizeof 进行计算（不好使）,不对
    ```
        char str[] = { 'D', 'a', 'r', 'r', 'e', 'n', '\0','i','s' };
    
        // 怎么获取长度？有一种方式计算（不好使）
        // printf("length is %d",sizeof(str)/sizeof(char));
    ```

3. 写一个方法读取字符串的长度
    ```
    int strlen_(char *str){
        // 怎么获取字符串的长度？ 不断读取字符，判断末尾 '\0'
    
        int len = 0;
        while (*str != '\0')
        {
            len++;
            str++;
        }
        return len;
    }
    ```


## 3.字符串的转换  
- `atoi(num_str);` // `str 转 int`如果不能转换就是 0 ，后面如果有其他不是数字的就会被剔除 12xxx -> 12
- `atof(num_str);` // `str 转 float` // 如果不能转换返回的是默认值 0.000000 
- `strtod(num_str, NULL);` // `str 转 double` // 如果不能转换返回的是默认值 0.000000 
    
    
## 4.字符串的比较
- `int rc = strcmp(str1, str2);`  // `区分大小写`比较，rc > 0 str1 比 str2 大
- `int rc = strcmpi(str1, str2);`  // `不区分大小写`比较
- `int rc = strncmp(str1, str2,7);` // `区分大小写`比较， count 代表的是比较字符串前几个是否相等
- `int rc = strnicmp(str1, str2,7);` // `不区分大小写`比较， count 代表的是比较字符串前几个是否相等

## 5.字符串查找，包含
- `char* pos = strstr(str, substr);` // 返回的是`字符串`第一次出现的位置（位置指针）, 如果没有找到返回的是空  
    
    获取位置: `int position = pos - str;`
    
- `char* pos =  strchr(name,'n');` // 返回的是`字符`第一次出现的位置（位置指针）, 如果没有找到返回的是空

## 6.字符串拼接

- strcpy(cpy, str); // 复制
- strcat(cpy,str1); // 拼接

```c
	char* str = "darren";
	char *str1 = " is";
	char cpy[strlen(str)+strlen(str1)];
	// str 会 copy 到 cpy 里面
	strcpy(cpy, str);
	// 拼接
	strcat(cpy,str1);
```
## 7.字符串截取

```c
char * substr(char * str,int start,int end){

	// 开辟一个字符串去存储我们的数据，开辟多大计算
	// char sub[end-start];
	int len = end - start;
	char* sub = (char*)malloc((len+1)*sizeof(char));// 记得加上1 ，在 NDK 一般会采用静态的数组存储 char sub[len]
	// malloc 一定要 free 

	// 遍历赋值
	str += start;
	for (int i = 0; i < len; i++)
	{
		sub[i] = *str;
		str++;// 指针往后逻一位 
	}
	// 标记字符串结尾，否则 print 无法判断结尾
	sub[len] = '\0';

	printf("%p\n",sub);

	// free(sub);

	return sub;
}
```

## 8.字符串小写转换
- `tolower(ch);` // A->a
- `toupper(ch);` // a->A

```c
#include <ctype.h>

void lower(char* dest,const char* source){
    while (*source != '\0'){
        // 拿当前字符
        char ch = *source;
        // 转换完成后赋值给 dest
        *dest = tolower(ch); // a->a A->a
        source++;
        dest++;
    }
    // 标记字符串结尾
    *dest = '\0';
}
```

## 9. 字符串的替换

```c
char* substr(const char* str,int start ,int end){
    // 开辟一个字符串去存储我们的数据，开辟多大计算
    // char sub[end -start];
    int len = end - start;
    char* sub = (char*)malloc(sizeof(char)*(len+1));// 记得+1，因为还有一个\0，在 NDK 一般会采用静态的数组存储 char sub[len]
    // malloc 一定要 free

    // 遍历赋值
    for(int i = 0; i< len; i++){
        sub[i] = str[start+i];
    }
    // 标记字符串结尾，否则 print 无法判断结尾
    sub[len] = '\0';

    printf("%p\n",sub);

    // free(sub);

    return sub;
}


char *str_replace(const char* str,const char* src,const char* dst) {
    char* pos = strstr(str,src);
    if(!pos)
        return const_cast<char *>(str);
    
    // 1. 计算新的数组大小
    char result[strlen(str)-strlen(src)+strlen(dst)];

    // 截取替换
    int start_position = pos - str;
    char* start = substr(str,0,start_position);
    char* end = substr(str,start_position+strlen(src),strlen(str));

    // 拼接
    strcpy(result,start);
    strcat(result,dst);
    strcat(result,end);

    return str_replace(result,src,dst);
}

// 字符串替换
int main(){
    char* str =  str_replace("aabbaabbfffaa","aa","ccc");

    printf("%s",str);

    getchar();
}
```