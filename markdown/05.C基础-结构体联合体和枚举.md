# <center>04.结构体联合体和枚举<center>
@[TOC](C基础)

# 知识点：

## 1.结构体的定义和使用

```c
// 第一种方式
struct Worker{ // 定义一个结构体， 相当于 java 的 class struct Worker worker; // 初始化，没有初始化的情况下，那么里面所有的属性都是没有初始值的，salary
    char name[10];
    int age;
    double salary;
};*/

// 第二种方式，可以直接取名字
struct Worker{ // 定义一个结构体， 相当于 java 的 class
    char name[20];
    int age;
    double salary;
}eastrise = {"Eastrise",25,1000},jack; // 这种方式会有一个默认的初始值,jack会有默认初始值

// 第三种方式，结构体嵌套
struct Worker{// 定义一个结构体，相当于 java 的 class
	char name[10];
	int age;
	double salary;

	// 工作， name grade
	Work work;
};

// 第四种方式，结构体嵌套
struct Worker{// 定义一个结构体，相当于 java 的 class
	char name[10];
	int age;
	double salary;

	struct Work{
		char name[10];
		char grade[10];
	}work;
	// 工作， name grade
	// Work work;
};
```
      
## 2.结构体指针和动态内存开辟

**通过指针取操作数据**

```c
struct Worker worker = {"Darren",23};
	Worker* worker_p = &worker;

	// 通过结构体指针去操作数据
	// worker.age = 24;
	worker_p->age = 24;// 结构体操作的另外一种方式，一般这种比较常用
	strcpy_s(worker_p->name,"Jack");

	printf("name = %s, age = %d", worker_p->name, worker_p->age);
```

**动态开辟结构体内存**

```c
// Worker* worker;// 创建了一个结构体指针 , 指针没有初始化内存，所以需要动态指定
	Worker* worker = (Worker*)malloc(sizeof(Worker));
	worker->age = 24;
	strcpy_s(worker->name, "Jack");

	printf("name = %s, age = %d", worker->name, worker->age);

	// 释放
	if (worker){
		free(worker);
		worker = NULL;
	}
```

**结构体的数组**

```c
// 创建结构体数组，第一种
	// Worker worker[10] = { {"Darren",23,1000},{},{},{},{} };// 创建了 10 个 ，静态开辟

	// worker[9] = {"Darren9",24,200};

	// printf("name = %s, age = %d\n", worker[9].name, worker[9].age);

	// 动态内存开辟 Worker* 结构体的指针
	Worker* worker = (Worker*)malloc(sizeof(Worker)*10);

	strcpy_s(worker->name,"Darren0");
	worker->age = 10;

	// 对第十个数据进行操作？
	worker += 9;
	strcpy_s(worker->name, "Darren9");
	worker->age = 9;


	printf("name = %s, age = %d", worker->name, worker->age);
```

## 3.结构体大小计算（字节对齐）
计算的规则：

1. 按照最大的字节去计算 
2. 算得时候只会按照基本数据类型去算
3. 首先会把所有字节数加起来，是否能够整除最大属性的字节数，如果不够为网上累加，一直加到能整除位置
4. 进阶，留一个思考
    
    
## 4.结构体和结构体指针取别名
`typedef Worker_ Worker_;`  好处`初始化时可以不用带 struct 关键字了`

```c
typedef Worker_ Worker_;
// 对结构体的指针取别名
typedef Worker_* Worker;

int main(){
	Worker worker = (Worker_*)malloc(sizeof(Worker_));

	printf("%s,%d,%lf",worker->name,worker->age,worker->salary);
}

```

## 5.联合体的定义和使用

`联合体只能存在一个，要么是 age ，要么是 name ` , 后定义的才存在

```c
union Person
{
	// 最能出现一个 ，不用累加，找最大值 10，12字节
	char name[10]; // 10 
	int age; // 4 
	double salary;// 8
};

int main(){
	// Person person = {"Darren"};
	 Person person;
	 strcpy_s(person.name,"Darren");
	 person.age = 24;
	 printf("name = %s,age = %d",person.name,person.age); // 只有 age 才有值，因为他是后定义的 
	printf("%d", sizeof(Person)); // 12
	getchar();
}
```

## 6. 联合体大小计算
`不用累加，取的最大值，最终是否够基本数据类型整除`


## 7.枚举的定义和使用

`枚举有点类似于 int`，没有指定的依照前面的数值累加

```c
enum CommentType
{
	TEXT = 10,TEXT_IMAGE =13,IMAGE
};

int main(){

	CommentType commentType = TEXT;
	CommentType commentType1 = TEXT_IMAGE;
	CommentType commentType2 = IMAGE;
	
	printf("%d,%d,%d", commentType, commentType1, commentType2); // 10,13,14

	getchar();
}
```
