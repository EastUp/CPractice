# <center>22.string、const关键字增强和引用本质分析<center>
@[TOC](C++基础)

# 知识点：

## 1. string 常见操作

### 1.1 遍历

`str.at(i)` 和 `str[i]`，区别在于 `str.at(i)`如果数组越界会报异常，而`str[i]`不一定

```c++
    // 1. 字符串的遍历
    for(int i = 0; i < str.length(); i++){
        cout << str[i] << endl;
    }

    // 2. 迭代器遍历
        for(string::iterator it = str.begin(); it < str.end(); it++){
            cout << *it <<endl;
        }
```

### 1.2 添加

```c++
    string str1 = "123";
    string str2 = "456";

    // str1 = str1 + str2;
    // str1 = str1.append(str2);
```

### 1.3 删除
```c++
    string str1 = "123 abc 123 abc 123";

    // str1.erase(0,3);// 第一个参数：从哪里开始，第二个参数：删除几个（默认值，字符串结尾）

    // 迭代器删除 2 bc 123 abc 123 解释
    for(string::iterator it = str1.begin(); it<str1.begin()+3; it++){ // 删除一个节后都会从头开始计算
        str1.erase(it);
    }
```

### 1.4 替换
```c++
    string str1 = "123 abc 123 abc 123";

    // 第一个参数：从哪里开始
    // 第二个参数：替换几个
    // 第三个参数：替换成谁
    str1.replace(0,6,"1234");
```

### 1.5 查找
```c++
    string str1 = "123 abc 123 abc 123";
    // 查找谁，从哪里开始
    // int position = str1.find("123",0);
    // 从后面往前找
    int position = str1.rfind("123");
```

### 1.6 大小写转换
```c++
    string str1 = "AAA abc BBB abc 123";
    // 转换成大写
    transform(str1.begin(),str1.end(),str1.begin(),::toupper);

    // 转小写
    transform(str1.begin(),str1.end(),str1.begin(),::tolower);
```

## 2. c++ 相对 c 的一些增强

### 2.1 实用性增强
```c++
    int a;
    printf("hello");
    
    a=10;
    int b; // 有的编译器不通过， c++ 中肯定能通过
    b = 10;
```

### 2.2 register 增强（c中报错，c++可以通过）

```c++
	// 寄存器上面的变量不能取地址，register 快速
	register int a = 10; 
	printf("%d",&a);
	getchar();
```

### 2.3 参数增强 (以下代码，c中没问题，c++中会检测报错)

```c++
// 参数处理增强
    int a = 10;
    int a;
    
    void main(){
    
        printf("%d",a);
    
        getchar();
    }

```

### 2.4 检测增强 (以下代码，c中没问题，c++中会检测报错)

```c++
    f(){
        return -1;
    }
    
    // 检测增强
    void mian(){
        printf("%d",f());
        getchar();
    }
```

## 3. const 关键字

const 使用场景：

```c++
    // 1. 修饰变量不可改变
    // const int number = 1;
    // 修饰指针 常量指针，指针常量
    int number = 1;
    // const int *n_p = &number;
    // *n_p = 3; // 常量指针不能改变值
    // 指针常量
    int *const n_p = &number;
    int a = 200;
    // n_p = &a; // 指针常量不能修改值

    // 拷贝构造函数，操作符重载，方法后面（都是由于它的成员不可改变）
```

区别：

- c 里面 const 是一个伪命题，可以通过指针去操作，编译时期的检测
- c++ 里面不光在编译时期做处理，还在运行时做了处理

## 4. 引用加强

其实引用的本质就是 `指针`

```c++
class Student {
private:
    string name;
public:
    Student(string name) : name(name) {}

    string &getName() {// java 想都别想
        return this->name;
    }
};

int main(){
    Student stu = Student("eastrise");

    // 改不动
    // stu.getName() = "Jack";

    stu.getName() = "Jack";

    cout << stu.getName() << endl;

    // vector front back

}
```

## 5. NDK 异常处理增强

```c++
class Exception : public out_of_range {
public:
    Exception(string mag) : out_of_range(mag) {
        cout << "构造函数" << endl;
    }

    ~Exception() {
        cout << "析构函数" << endl;
    }
};

void c_method() { // 如果是自己的写，1000 多行
    cout << "抛异常" << endl;
    throw new Exception("异常了");
}

int main() {
    try {
        c_method();
    } catch (Exception *e) {
        // Exception：多次构造函数和析构函数
        // Exception&：避免了多次创建对象（最多的）
        // Exception*：创建的对象会被析构，如果使用局部函数或者成员就会是一个野指针
        cout << "try异常" << e->what() << endl;
        delete e;
    } catch (...) {
        cout << "其它异常" << endl;
    }
}
```





















